
using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.InteropServices.WindowsRuntime;
using System.Threading;
using UnityEngine;

public class RemoteTransform : Player
{
    [Header("차징 스킬 변수")]
    //public float handleMaxTime; // 최대 차징 시간
    //float handletimer; // 차징 타이머 (시간이 증가하는 만큼 범위 증가)
    public float handlediameterrangemax; // 차징 최대 범위
    public float handlediameterrangemin; // 차징 최소 범위
    public SphereCollider handlerange; // 차징 범위 콜라이더
    public float chargingBufferTimer;
    public float chargingBufferTimeMax;


    public event Action<GameObject> RemoteObjectEvent;

    public List<GameObject> remoteObj; // 탐지 범위에 저장될 상호작용 오브젝트 정보



 public   GameObject closestObject;
    GameObject activeEffectInstance;
    public float minimumdistance;

    public bool Charging;

    [Header("빔 관련 변수")]
    public GameObject laserPrefab; // 빔 스킬 프리팹
    public GameObject laserEffect; // 빔 이펙트 오브젝트

    //[Header("체인 라이트닝 변수")]
    //public List<GameObject> enemies; 
    //public GameObject chain; // 체인 오브젝트    
    //public float chainSearchRange; // 체인 오브젝트의 탐지 범위
    //[Header("체인 라이트닝 탐색 큐브 조정")]
    //public Vector3 searchCubeRange; // 플레이어 인지 범위를 Cube 사이즈로 설정
    //public Vector3 searchCubePos; // Cube 위치 조정
    //public bool onChain; // 스킬 사용 시 true변환



    private void Awake()
    {
        //handlerange.
        handlerange = transform.Find("SKillChargeRadius").GetComponent<SphereCollider>();

    }

    private void Update()
    {
        BaseBufferTimer();
   
        //for문 사용했으니 최적화 필요함
        UpdateClosestRemoteObjectEffect();

        RemoteObjectEvent?.Invoke(closestObject);
        /*if (chargingBufferTimer > 0 && !Charging)
        {
            chargingBufferTimer -= Time.deltaTime;
        }*/
    }
    void UpdateClosestRemoteObjectEffect()
    {
        float closestdistance = float.MaxValue;
        GameObject newclosestobject = null;
       
        foreach (var obj in remoteObj)
        {
            float distance = Vector3.Distance(transform.position, obj.transform.position);
            if (distance < closestdistance)
            {
                closestdistance = distance;
                newclosestobject = obj;
            }
        }
        if (closestdistance > minimumdistance)
        {
            closestObject = null;

            return;
        }
        if (newclosestobject != closestObject)
        {
            closestObject = newclosestobject;


        }
       
    }
    public override void Skill1()
    {
        if (Input.GetKey(KeyCode.UpArrow) && Input.GetKeyDown(KeyCode.X))
        {
            //Charging = true;
            if (closestObject != null)
            {
                Humonoidanimator.Play("Charge");
                ActiveRemoteObject();
            }
        }

        //if (!Input.GetKey(KeyCode.UpArrow) && Charging
        //    || !Input.GetKey(KeyCode.X) && Charging)
        //{
        /*if (handlerange.radius < handlediameterrangemin)
        {
            handlerange.radius = handlediameterrangemin;
        }*/
        //Charging = false;
        //chargingBufferTimer = chargingBufferTimeMax;
        //Humonoidanimator.SetBool("Charge", Charging);
        //if (timeScale < handlediameterrangemin)
        //{
        //    handlerange.transform.localScale = new Vector3(handlediameterrangemin, handlediameterrangemin, 0);
        //}
        //handlerange.gameObject.SetActive(true);
        //handlerange.gameObject.SetActive(Charging);

        //}
    }

    public override void Attack()
    {
        if (attackBufferTimer > 0 && canAttack)
        {
            canAttack = false;

            StartCoroutine(LaserAttack());
        }
    }

    IEnumerator LaserAttack()
    {
        Humonoidanimator.Play("Attack");
        if (PoolingManager.instance != null)
            PoolingManager.instance.GetPoolObject("Laser", firePoint);
        else
            Instantiate(laserPrefab, this.gameObject.transform.position, this.transform.rotation);
        yield return new WaitForSeconds(PlayerStat.instance.attackDelay);

        canAttack = true;
    }

  
    #region 오버랩스피어 시도
 
    #endregion
    public GameObject ACtiveGameObject;
    public void SearchRemoteObjectList()
    {

    }
    public void ActiveRemoteObject()
    {
        if (closestObject != null)
            closestObject.GetComponent<RemoteObject>().Active();
       
    }
}
